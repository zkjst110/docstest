

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>HVM跨合约功能使用手册 &mdash; hyperchain  documentation</title>
  

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> hyperchain
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">平台介绍:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Introduction.html">平台介绍</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Version%20information.html">版本信息</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">快速入门:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../General%20Concepts.html">通用概念</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Prepare.html">准备工作</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Deployedfile.html">部署运维</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">基础协议:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../consensus%20mechanism.html">共识机制</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Networking%20protocol.html">网络协议</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../execution%20engine.html">执行引擎</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Storage%20model.html">存储模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../security%20mechanism.html">加密机制</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">扩展协议:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Architecture%20development.html">架构拓展</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Digital%20Service.html">数字服务</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Safe%20Privacy.html">隐私保护</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Governonce%20and%20audit.html">治理与审计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Data%20management.html">数据管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Operation%20manage.html">运维管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Ecological%20components.html">区块链生态组件</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../External%20Interface.html">外部接口</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">用户手册:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Chain%20Authority%20Management.html">链级权限管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Node%20and%20zone%20management.html">节点及分区管理</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Consensus%20related%20user%20manual.html">共识相关使用手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Cross%20domain%20network%20User%20Manual.html">跨域网络使用手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Data%20storage%20and%20management.html">数据存储使用手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Password%20related.html">密码学相关</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Security%20Audit.html">安全审计</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Data%20Monitor.html">数据监控</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../qulian%20blockchain%20browser.html">趣链区块链浏览器</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../VM%20Related%20User%20Manual.html">（用户）智能合约使用手册</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Module.html">（用户）组件库</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">应用场景:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../application.html">应用案例</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../NFT%20and%20contract%20writing.html">数字藏品合约编写</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">更多资源:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../Community_Resources.html">社区与资源</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">hyperchain</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>HVM跨合约功能使用手册</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="../../_sources/VM Related User Manual/HVM/HVM invocation across contracts.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="hvm">
<span id="hvm-invocation-across-contracts"></span><h1>HVM跨合约功能使用手册<a class="headerlink" href="#hvm" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>概念说明<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>在区块链中，有些功能需要通过多个智能合约完成，在这种情况下，需要使用到合约的跨合约调用。在HVM中，用户可以通过hvm-sdk提供的接口获取到跨合约实例并进行调用。</p>
<p>HVM提供了两种跨合约调用实例：</p>
<ul class="simple">
<li><p>contract</p></li>
<li><p>library</p></li>
</ul>
<p>其中被跨合约的两个内置变量sender将变成发起跨合约调用的合约地址，origin则同发起跨合约调用的相同，都为交易发起者账户地址。</p>
<div class="section" id="contract">
<h3>contract实例<a class="headerlink" href="#contract" title="Permalink to this headline">¶</a></h3>
<p>调用contract实例时，会影响到该合约账本中的状态变量。即如果在跨合约调用中被调用contract实例合约对应的合约状态变量被修改了，那么在持久化阶段，被调用合约中的被修改的状态变量也将被持久化。</p>
<p>在不跨合约的场景下，正常调用或者合约部署是，合约默认为contract实例。</p>
</div>
<div class="section" id="library">
<h3>library实例<a class="headerlink" href="#library" title="Permalink to this headline">¶</a></h3>
<p>调用library实例时，被调用合约是以工具类的角色存在，对被调用合约的修改最终不会在账本中体现，即所有修改均会被抛弃。</p>
</div>
</div>
<div class="section" id="id2">
<h2>使用说明<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>在hvm-sdk的BaseContract中提供了内部类CrossCall，用于获取跨合约实例，CrossCall的字段属性如下表所示。</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 17%" />
<col style="width: 10%" />
<col style="width: 72%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>名称</p></th>
<th class="head"><p>类型</p></th>
<th class="head"><p>描述</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>crossAddress</p></td>
<td><p>String</p></td>
<td><p>被调用的合约地址</p></td>
</tr>
<tr class="row-odd"><td><p>isLibrary</p></td>
<td><p>boolean</p></td>
<td><p>true表示获取library实例，false表示获取contract实例</p></td>
</tr>
</tbody>
</table>
<div class="section" id="id3">
<h3>定义说明<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>在介绍跨合约调用的流程前，我们先规定需要使用到的概念：</p>
<div class="section" id="a">
<h4><strong>合约A</strong><a class="headerlink" href="#a" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">A</span> <span class="n">extends</span> <span class="n">BaseContract</span> <span class="n">implements</span> <span class="n">IA</span> <span class="p">{</span>
   <span class="n">public</span> <span class="n">void</span> <span class="n">funcA</span><span class="p">(){}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>合约A继承了BaseContract类，实现了IA中声明的方法，该合约方法中会调用合约B的方法。</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">interface</span> <span class="n">IA</span> <span class="n">extends</span> <span class="n">BaseContractInterface</span> <span class="p">{</span>
   <span class="n">void</span> <span class="n">funcA</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>IA继承了BaseContractInterface类。</p>
</div>
<div class="section" id="b">
<h4><strong>合约B</strong><a class="headerlink" href="#b" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">B</span> <span class="n">extends</span> <span class="n">BaseContract</span> <span class="n">implements</span> <span class="n">IB</span> <span class="p">{</span>
   <span class="n">public</span> <span class="n">void</span> <span class="n">funcB</span><span class="p">(){}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>合约B继承了BaseContract类，实现了IB中声明的方法。</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">interface</span> <span class="n">IB</span> <span class="n">extends</span> <span class="n">BaseContractInterface</span> <span class="p">{</span>
   <span class="n">void</span> <span class="n">funcB</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>IB继承了BaseContractInterface类。</p>
</div>
</div>
<div class="section" id="id4">
<h3>注解说明<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>CrossCall需要配合相应的注解来使用。用户必须在合约声明CrossCall字段时，配合使用 <cite>&#64;Contract</cite> 和 <cite>&#64;Library</cite> 注解来声明实例类型，并且需要设置合约的地址。</p>
<p>如果我们要在合约A中调用合约B的方法，我们需要先在平台部署合约B，然后在合约A中声明一个带有注解的CrossCall字段，注解中的address即我们部署好的合约B地址，如下面的代码所示:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">A</span> <span class="n">extends</span> <span class="n">BaseContract</span> <span class="n">implements</span> <span class="n">IA</span> <span class="p">{</span>
   <span class="nd">@Contract</span><span class="p">(</span><span class="n">address</span> <span class="o">=</span> <span class="s2">&quot;0x209a1a980946e899b2cb4fc0ecb2b921f64bd236&quot;</span><span class="p">)</span>
   <span class="n">private</span> <span class="n">CrossCall</span> <span class="n">call</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CrossCall</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h3>跨合约调用<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>我们给CrossCall提供了一个获取被调用合约实例的方法 <cite>getCrossContract</cite>  ,若 <cite>isLibrary=true</cite> ，返回合约地址对应的library实例；若 <cite>isLibrary=false</cite> ，返回合约地址对应的contract实例。需要注意的是，该合约地址对应的合约主体类必须实现 <strong>BaseContractInterface</strong> 接口，可以使用对应 <strong>合约接口类型变量</strong> 进行接收。</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">final</span> <span class="o">&lt;</span><span class="n">T</span> <span class="n">extends</span> <span class="n">BaseContractInterface</span><span class="o">&gt;</span> <span class="n">T</span> <span class="n">getCrossContract</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>在我们合约A中声明了含有 <cite>&#64;contract</cite> 的CrossCall字段以后，我们可以在合约A的方法中，通过 <cite>getCrossContract</cite> 获取合约B的contract实例，然后调用合约B的方法。</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">A</span> <span class="n">extends</span> <span class="n">BaseContract</span> <span class="n">implements</span> <span class="n">IA</span> <span class="p">{</span>
   <span class="nd">@Contract</span><span class="p">(</span><span class="n">address</span> <span class="o">=</span> <span class="s2">&quot;0x209a1a980946e899b2cb4fc0ecb2b921f64bd236&quot;</span><span class="p">)</span>
   <span class="n">private</span> <span class="n">CrossCall</span> <span class="n">call</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CrossCall</span><span class="p">();</span>

   <span class="n">public</span> <span class="n">void</span> <span class="n">funcA</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">IB</span> <span class="n">iB</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">getCrossContract</span><span class="p">();</span>
       <span class="n">iB</span><span class="o">.</span><span class="n">funcB</span><span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="id6">
<h2>注意事项<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>下面是一些在跨合约调用中需要注意的方法，或者是建议的用法。</p>
<div class="section" id="id7">
<h3>同全限定名类<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<p>在一个调用中涉及到的所有的合约中不能出现：使用全限定类名相同(即包名和类名都相同)，但是具体实现不同的类。</p>
<p>若出现，将会得到如下异常:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cn</span><span class="o">.</span><span class="n">hyperchain</span><span class="o">.</span><span class="n">sdk</span><span class="o">.</span><span class="n">exception</span><span class="o">.</span><span class="n">RequestException</span><span class="p">:</span> <span class="n">Deploy</span> <span class="n">contract</span> <span class="n">failed</span><span class="p">:</span> <span class="n">DEPLOY_CONTRACT_FAILED</span><span class="p">:</span><span class="n">java</span><span class="o">.</span><span class="n">lang</span><span class="o">.</span><span class="n">RuntimeException</span><span class="p">:</span> <span class="n">init</span> <span class="n">library</span> <span class="n">failed</span><span class="p">:</span> <span class="n">found</span> <span class="n">a</span> <span class="n">duplicate</span> <span class="n">class</span><span class="p">:</span> <span class="n">org</span><span class="o">.</span><span class="n">example</span><span class="o">.</span><span class="n">bean</span><span class="o">.</span><span class="n">Man</span><span class="p">,</span> <span class="n">please</span> <span class="n">change</span> <span class="n">it</span>
</pre></div>
</div>
</div>
<div class="section" id="id8">
<h3>跨合约调用链<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>目前的跨合约调用只支持一层跨合约调用。有以下跨合约调用场景：</p>
<ol class="arabic simple">
<li><p>合约A中，调用了contract实例B的方法和contract实例C的方法。 <strong>调用成功</strong> 。</p></li>
<li><p>合约A中，调用了contract实例B的方法，该实例B的方法中又跨合约调用了contract实例C的方法。 <strong>调用失败</strong> 。</p></li>
</ol>
</div>
<div class="section" id="id9">
<h3>合约生命周期钩子方法<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>在每次获取contract实例（library实例）时，均会触发contract实例（library实例）的onCreated钩子函数，即使该实例曾经已经被获取过。</p></li>
<li><p>合约可以通过在 <strong>onCreated</strong> 钩子函数中，通过检查 <strong>sender</strong> 和 <strong>origin</strong> 地址，来进行权限控制，若想要终止对自己跨合约调用只需要在 <strong>onCreated</strong> 钩子函数中抛出 <strong>RuntimeException</strong> 即可。合约可以通过 <strong>getSender()</strong> 获取到本次对自己的直接调用者(用户或者合约)的地址，可以通过 <strong>getOrigin()</strong> 方法获取到调用链的起点(必然是用户)的地址。</p></li>
<li><p>因为library实例的变更最终不会被持久化到账本，所以library实例的 <strong>onPreCommit</strong> 和 <strong>onCommited</strong> 钩子函数不会被触发。</p></li>
<li><p><strong>onCreated</strong> 的执行顺序与合约执行顺序相同。 <strong>onPreCommit</strong> 和 <strong>onCommited</strong> 钩子方法的调用顺序与合约执行顺序相反。比如：有调用链A-&gt;B，那么 <strong>onCreated</strong> 的调用顺序为A-&gt;B，而 <strong>onPreCommit</strong> 和 <strong>onCommited</strong> 的调用顺序为B-&gt;A。</p></li>
</ol>
</div>
</div>
<div class="section" id="id10">
<h2>实例演示<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>本小节将给出一个跨合约调用的实例，实例中包含两个合约：NumAdd合约和CrossCall合约。我们将通过跨合约调用的方式，在crossCall合约中调用addNum合约中的方法。合约的调用与部署都基于 <cite>LiteSDK</cite> 。</p>
<div class="section" id="numadd">
<h3>NumAdd合约<a class="headerlink" href="#numadd" title="Permalink to this headline">¶</a></h3>
<p>NumAdd合约代码如下。在合约部署阶段，通过 <cite>onInit</cite> 方法初始化 <cite>num=100</cite> 。合约提供了 <cite>getNum</cite> 方法获取num的值以及 <cite>addNum</cite> 方法增加num的值。</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">NumAdd</span> <span class="n">extends</span> <span class="n">BaseContract</span> <span class="n">implements</span> <span class="n">INumAdd</span> <span class="p">{</span>
   <span class="nd">@StoreField</span>
   <span class="nb">int</span> <span class="n">num</span><span class="p">;</span>

   <span class="nd">@Override</span>
   <span class="n">public</span> <span class="n">void</span> <span class="n">onInit</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="nd">@Override</span>
   <span class="n">public</span> <span class="nb">int</span> <span class="n">getNum</span><span class="p">()</span> <span class="p">{</span>
       <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="nd">@Override</span>
   <span class="n">public</span> <span class="nb">int</span> <span class="n">addNum</span><span class="p">(</span><span class="nb">int</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">num</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
       <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id11">
<h3>部署NumAdd合约<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<p>首先，我们部署打包好的NumAdd合约，并输出部署好的合约地址。</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="n">void</span> <span class="n">deployNumAdd</span><span class="p">()</span> <span class="n">throws</span> <span class="n">IOException</span><span class="p">,</span> <span class="n">RequestException</span> <span class="p">{</span>
   <span class="o">//</span><span class="mf">1.</span><span class="n">部署合约</span>
   <span class="n">InputStream</span> <span class="n">is1</span> <span class="o">=</span> <span class="n">FileUtil</span><span class="o">.</span><span class="n">readFileAsStream</span><span class="p">(</span><span class="n">jarPath1</span><span class="p">);</span>
   <span class="n">DefaultHttpProvider</span> <span class="n">defaultHttpProvider</span> <span class="o">=</span> <span class="n">new</span> <span class="n">DefaultHttpProvider</span><span class="o">.</span><span class="n">Builder</span><span class="p">()</span><span class="o">.</span><span class="n">setUrl</span><span class="p">(</span><span class="n">defaultURL</span><span class="p">)</span><span class="o">.</span><span class="n">build</span><span class="p">();</span>
   <span class="n">ProviderManager</span> <span class="n">providerManager</span> <span class="o">=</span> <span class="n">ProviderManager</span><span class="o">.</span><span class="n">createManager</span><span class="p">(</span><span class="n">defaultHttpProvider</span><span class="p">);</span>

   <span class="n">ContractService</span> <span class="n">contractService</span> <span class="o">=</span> <span class="n">ServiceManager</span><span class="o">.</span><span class="n">getContractService</span><span class="p">(</span><span class="n">providerManager</span><span class="p">);</span>
   <span class="n">AccountService</span> <span class="n">accountService</span> <span class="o">=</span> <span class="n">ServiceManager</span><span class="o">.</span><span class="n">getAccountService</span><span class="p">(</span><span class="n">providerManager</span><span class="p">);</span>
   <span class="n">Account</span> <span class="n">account</span> <span class="o">=</span> <span class="n">accountService</span><span class="o">.</span><span class="n">fromAccountJson</span><span class="p">(</span><span class="n">accountJson</span><span class="p">);</span>

   <span class="n">Transaction</span> <span class="n">transaction</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Transaction</span><span class="o">.</span><span class="n">HVMBuilder</span><span class="p">(</span><span class="n">account</span><span class="o">.</span><span class="n">getAddress</span><span class="p">())</span><span class="o">.</span><span class="n">deploy</span><span class="p">(</span><span class="n">is1</span><span class="p">)</span><span class="o">.</span><span class="n">build</span><span class="p">();</span>
   <span class="n">transaction</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">account</span><span class="p">);</span>

   <span class="n">ReceiptResponse</span> <span class="n">receiptResponse</span> <span class="o">=</span> <span class="n">contractService</span><span class="o">.</span><span class="n">deploy</span><span class="p">(</span><span class="n">transaction</span><span class="p">)</span><span class="o">.</span><span class="n">send</span><span class="p">()</span><span class="o">.</span><span class="n">polling</span><span class="p">();</span>
   <span class="n">String</span> <span class="n">contractAddress</span> <span class="o">=</span> <span class="n">receiptResponse</span><span class="o">.</span><span class="n">getContractAddress</span><span class="p">();</span>
   <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;contract numAdd address: &quot;</span> <span class="o">+</span> <span class="n">contractAddress</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
<p>输出合约地址:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">contract</span> <span class="n">numAdd</span> <span class="n">address</span><span class="p">:</span> <span class="mh">0xd40db0476049f1cf71c59a5ef754bd1c77d1cede</span>
</pre></div>
</div>
</div>
<div class="section" id="crosscallcontract">
<h3>CrossCallContract<a class="headerlink" href="#crosscallcontract" title="Permalink to this headline">¶</a></h3>
<p>在部署好NumAdd合约后，我们在CrossCallContract合约中编写调用addNum合约逻辑的代码。合约中声明了一个 <cite>CrossCall</cite> 类型的字段，使用 <cite>&#64;Contract</cite> 注解标识这是一个 <cite>Contract</cite> 实例，注解中的address属性对应前面部署好的NumAdd合约的地址。</p>
<p>CrossCallContract合约包含了两个方法：</p>
<ul class="simple">
<li><p>crossCallGetNum：调用NumAdd合约的getNum方法，打印num的值。</p></li>
<li><p>crossCallAddNum：调用NumAdd合约的getNum方法，打印num的值；调用NumAdd的addNum方法，使num的值加1.</p></li>
</ul>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nc">CrossCallContract</span> <span class="n">extends</span> <span class="n">BaseContract</span> <span class="n">implements</span> <span class="n">ICrossCallContract</span> <span class="p">{</span>
   <span class="nd">@Contract</span><span class="p">(</span><span class="n">address</span> <span class="o">=</span> <span class="s2">&quot;0xd40db0476049f1cf71c59a5ef754bd1c77d1cede&quot;</span><span class="p">)</span>
   <span class="n">private</span> <span class="n">CrossCall</span> <span class="n">contractCall</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CrossCall</span><span class="p">();</span>

   <span class="n">public</span> <span class="n">String</span> <span class="n">crossCallGetNum</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">INumAdd</span> <span class="n">iNumAdd</span> <span class="o">=</span> <span class="n">contractCall</span><span class="o">.</span><span class="n">getCrossContract</span><span class="p">();</span>
       <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">iNumAdd</span><span class="o">.</span><span class="n">getNum</span><span class="p">();</span>
       <span class="k">return</span> <span class="s2">&quot;crossCallGetNum: the num is &quot;</span> <span class="o">+</span> <span class="n">num</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="n">public</span> <span class="n">String</span> <span class="n">crossCallAddNum</span><span class="p">()</span> <span class="p">{</span>
       <span class="n">INumAdd</span> <span class="n">iNumAdd</span> <span class="o">=</span> <span class="n">contractCall</span><span class="o">.</span><span class="n">getCrossContract</span><span class="p">();</span>
       <span class="nb">int</span> <span class="n">num</span> <span class="o">=</span> <span class="n">iNumAdd</span><span class="o">.</span><span class="n">getNum</span><span class="p">();</span>
       <span class="n">iNumAdd</span><span class="o">.</span><span class="n">addNum</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
       <span class="k">return</span> <span class="s2">&quot;crossCallAddNum: the num is &quot;</span> <span class="o">+</span> <span class="n">num</span> <span class="o">+</span> <span class="s2">&quot;, and add 1&quot;</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id12">
<h3>调用CrossCallContract合约<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p>CrossCallContract合约的部署与NumAdd合约的部署类似，这里不再赘述。部署好CrossCallContract合约后，我们通过直接调用的方式调用CrossCall合约。</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span>public void deployCrossCall() throws IOException, RequestException {
   //1.部署CrossCallContract合约
   ……

   //2.直接调用crossCallGetNum
   InvokeDirectlyParams invokeDirectlyParams1 = new InvokeDirectlyParams.ParamBuilder(&quot;crossCallGetNum&quot;).build();
   Transaction transaction1 = new Transaction.HVMBuilder(account.getAddress())
           .invokeDirectly(contractAddress, invokeDirectlyParams1)
           .build();
   transaction1.sign(account);
   ReceiptResponse receiptResponse1 = contractService
           .invoke(transaction1).send().polling();
   System.out.println(Decoder.decodeHVM(receiptResponse1.getRet(), String.class));

   //3.直接调用crossCallGetNum
   InvokeDirectlyParams invokeDirectlyParams2 = new InvokeDirectlyParams.ParamBuilder(&quot;crossCallAddNum&quot;).build();
   Transaction transaction2 = new Transaction.HVMBuilder(account.getAddress())
           .invokeDirectly(contractAddress, invokeDirectlyParams2)
           .build();
   transaction2.sign(account);
   ReceiptResponse receiptResponse2 = contractService
           .invoke(transaction2).send().polling();
   System.out.println(Decoder.decodeHVM(receiptResponse2.getRet(), String.class));

   //4.再次直接调用crossCallGetNum
   Transaction transaction3 = new Transaction.HVMBuilder(account.getAddress())
           .invokeDirectly(contractAddress, invokeDirectlyParams1)
           .build();
   transaction3.sign(account);
   ReceiptResponse receiptResponse3 = contractService
           .invoke(transaction3).send().polling();
   System.out.println(Decoder.decodeHVM(receiptResponse3.getRet(), String.class));
}
</pre></div>
</div>
</div></blockquote>
<p>上面的代码进行了三次调用：</p>
<ol class="arabic simple">
<li><p>调用crossCallGetNum方法，获取num的值，打印结果为</p></li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">crossCallGetNum</span><span class="p">:</span> <span class="n">the</span> <span class="n">num</span> <span class="ow">is</span> <span class="mi">100</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="2">
<li><p>调用crossCallAddNum方法，使num的值加1，打印结果为</p></li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">crossCallAddNum</span><span class="p">:</span> <span class="n">the</span> <span class="n">num</span> <span class="ow">is</span> <span class="mi">100</span><span class="p">,</span> <span class="ow">and</span> <span class="n">add</span> <span class="mi">1</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple" start="3">
<li><p>调用crossCallGetNum方法，获取num的值，打印结果为</p></li>
</ol>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">crossCallGetNum</span><span class="p">:</span> <span class="n">the</span> <span class="n">num</span> <span class="ow">is</span> <span class="mi">101</span>
</pre></div>
</div>
</div></blockquote>
<p>通过上面的例子，我们可以发现被CrossCallContract合约调用的NumAdd合约将num的值被持久化记录到了账本上，符合contract实例的特点。有兴趣的读者可以在CrossCallContract合约中将CrossCall的 <cite>&#64;Contract</cite> 注解类型改为 <cite>&#64;Library</cite> ，观察区别。</p>
<p>下面是给出的跨合约调用demo，可以下载在本地体验。调用测试代码码时，请先部署NumAdd合约，然后在CrossCallContract合约的跨合约注解中，写入这个地址。接着执行 <cite>mvn package</cite> 命令，生成CrossCallContract合约的jar包。</p>
<p><strong>【源码包可参考HVM使用手册 - HVM合约Demo附件源码-hvm-manual-demo的crossCallDemo目录】</strong></p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2016-2023, Hangzhou Hyperchain Technology Co., Ltd..

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>